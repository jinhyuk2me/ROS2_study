#!/usr/bin/env python3
"""
PID 제어기 모듈 (Proportional-Integral-Derivative Controller)

이 파일은 일반적인 PID 제어기를 구현한 모듈입니다.
PID 제어기는 제어공학에서 가장 널리 사용되는 피드백 제어 방식입니다.

PID 제어기 동작 원리:
- P(비례): 현재 오차에 비례하여 제어 출력 생성
- I(적분): 과거 오차의 누적합에 비례하여 제어 출력 생성  
- D(미분): 오차의 변화율에 비례하여 제어 출력 생성

수학적 표현:
u(t) = Kp*e(t) + Ki*∫e(t)dt + Kd*de(t)/dt

여기서:
- u(t): 제어 출력
- e(t): 오차 (목표값 - 현재값)
- Kp, Ki, Kd: 각각 비례, 적분, 미분 게인

각 항의 역할:
- P항: 즉각적인 반응, 오차가 클수록 큰 출력
- I항: 정상상태 오차 제거, 오차가 계속 누적되면 출력 증가
- D항: 시스템 안정성 향상, 급격한 변화 억제

작성자: [작성자명]
날짜: [작성일]
"""

import time  # 시간 측정을 위한 Python 표준 라이브러리

class PID:
    """
    PID 제어기 클래스
    
    이 클래스는 비례-적분-미분 제어기를 구현합니다.
    오차 신호를 입력받아 적절한 제어 출력을 계산하여 시스템을 제어합니다.
    
    사용 예시:
        pid = PID()
        pid.P = 1.0    # 비례 게인 설정
        pid.I = 0.1    # 적분 게인 설정  
        pid.D = 0.05   # 미분 게인 설정
        pid.max_state = 10.0  # 최대 출력 제한
        
        while running:
            error = target - current_value
            control_output = pid.update(error)
    """
    
    def __init__(self):
        """
        PID 제어기 초기화
        
        모든 파라미터와 상태 변수들을 초기값으로 설정합니다.
        """
        # =============================================================================
        # PID 게인 파라미터 (사용자가 설정해야 하는 값들)
        # =============================================================================
        self.P = 0.0  # 비례 게인 (Kp): 현재 오차에 대한 반응 강도
        self.I = 0.0  # 적분 게인 (Ki): 누적 오차에 대한 반응 강도  
        self.D = 0.0  # 미분 게인 (Kd): 오차 변화율에 대한 반응 강도
        
        # =============================================================================
        # 출력 제한 파라미터
        # =============================================================================
        self.max_state = 0.0  # 최대 제어 출력 값 (상한선)
        self.min_state = 0.0  # 최소 제어 출력 값 (하한선)
        
        # =============================================================================
        # 내부 상태 변수들 (PID 계산에 사용되는 변수들)
        # =============================================================================
        self.pre_state = 0.0         # 이전 오차 값 (미분 계산용)
        self.dt = 0.0                # 시간 간격 (Δt)
        self.integrated_state = 0.0  # 오차의 누적합 (적분 계산용)
        self.pre_time = time.time()  # 이전 시간 (시간 간격 계산용)
        
    def update(self, state):
        """
        PID 제어 출력 계산 함수
        
        현재 오차(state)를 입력받아 PID 알고리즘에 따라 제어 출력을 계산합니다.
        
        Args:
            state (float): 현재 오차 값 (목표값 - 현재값)
            
        Returns:
            float: 계산된 제어 출력 값
            
        PID 계산 과정:
        1. 시간 간격(dt) 계산
        2. 미분항(D) 계산 - 오차의 변화율
        3. 적분항(I) 계산 - 오차의 누적합
        4. PID 출력 계산 - P + I + D 항의 합
        5. 출력 제한 적용
        6. 다음 계산을 위한 상태 업데이트
        """
        
        # =============================================================================
        # 1. 시간 간격 계산 (Δt)
        # =============================================================================
        # 현재 시간과 이전 update 호출 시간의 차이를 계산
        self.dt = time.time() - self.pre_time

        # =============================================================================
        # 2. 미분항(D) 계산 - de(t)/dt
        # =============================================================================
        # 오차의 변화율을 계산하여 시스템의 급격한 변화를 예측
        if self.dt == 0.:
            # 시간 간격이 0이면 미분 불가능 (0으로 나누기 방지)
            state_D = 0.
        else:
            # 미분 ≈ (현재 오차 - 이전 오차) / 시간 간격
            state_D = (state - self.pre_state) / self.dt

        # =============================================================================
        # 3. 적분항(I) 계산 - ∫e(t)dt
        # =============================================================================
        # 오차의 누적합을 계산하여 정상상태 오차를 제거
        # 새로운 누적 오차 = 현재 오차 + 이전까지의 누적 오차
        state_I = state + self.integrated_state

        # =============================================================================
        # 4. PID 출력 계산
        # =============================================================================
        # PID 공식: u(t) = Kp*e(t) + Ki*∫e(t)dt + Kd*de(t)/dt
        # 여기서:
        # - self.P * state: 비례항 (현재 오차에 비례)
        # - self.I * state_I * self.dt: 적분항 (누적 오차에 비례, dt로 스케일링)
        # - self.D * state_D: 미분항 (오차 변화율에 비례)
        out = self.P*state + self.D*state_D + self.I*state_I * self.dt

        # =============================================================================
        # 5. 출력 제한 적용 (Saturation)
        # =============================================================================
        # 제어 출력이 허용 범위를 벗어나지 않도록 제한
        if abs(out) > self.max_state:
            # 최대값을 초과하면 최대값으로 제한 (부호 유지)
            out = self.max_state if out > 0 else -self.max_state
        elif abs(out) < self.min_state:
            # 최소값보다 작으면 최소값으로 제한 (부호 유지)
            out = self.min_state if out > 0 else -self.min_state

        # =============================================================================
        # 6. 다음 계산을 위한 상태 업데이트
        # =============================================================================
        self.pre_state = state           # 현재 오차를 다음번 미분 계산을 위해 저장
        self.integrated_state = state_I  # 누적 오차를 다음번 적분 계산을 위해 저장
        self.pre_time = time.time()      # 현재 시간을 다음번 시간 간격 계산을 위해 저장

        return out